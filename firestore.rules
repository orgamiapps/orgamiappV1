rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Allow users to read/write their own user data
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }
    
    // Allow users to read/write their own customer data
    // Users can only access their own customer document
    match /Customers/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
      allow create: if request.auth != null && request.auth.uid == request.resource.data.uid;
      // Allow access to special customer documents for manual/without_login users
      allow read, write: if request.auth != null && (userId == 'manual' || userId == 'without_login');
      // Allow reading any customer document for authenticated users (for debugging)
      allow read: if request.auth != null;

      // Followers subcollection: allow public reads; writes by follower or profile owner
      match /followers/{followerId} {
        allow read: if request.auth != null;
        allow create: if request.auth != null && request.auth.uid == followerId;
        allow delete: if request.auth != null && (request.auth.uid == followerId || request.auth.uid == userId);
        allow update: if false;
      }

      // Blocks subcollection: only the owner can read/write their own blocks
      match /blocks/{blockedUserId} {
        allow read, create, delete: if request.auth != null && request.auth.uid == userId;
        allow update: if false; // updates not supported; delete+create instead
      }

      // Following subcollection: allow public reads; only the owner can modify their following
      match /following/{followingId} {
        allow read: if request.auth != null;
        allow create: if request.auth != null && request.auth.uid == userId;
        allow delete: if request.auth != null && request.auth.uid == userId;
        allow update: if false;
      }
    }
    
    // Allow authenticated users to access Settings collection for app configuration
    match /Settings/{document} {
      allow read, write: if request.auth != null;
    }
    
    // Allow authenticated users to create and read comments
    match /Comments/{commentId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null;
      allow update, delete: if request.auth != null && 
        request.auth.uid == resource.data.userId;
    }
    
    // Allow authenticated users to create and read attendance records
    // Users can read attendance records (filtered by application code)
    // Event hosts can read attendance for their events
    match /Attendance/{attendanceId} {
      allow create: if request.auth != null;
      allow read: if request.auth != null;
      allow update, delete: if request.auth != null && 
        (request.auth.uid == resource.data.customerUid || 
         resource.data.customerUid == 'manual' || 
         resource.data.customerUid == 'without_login');
    }
    
    // Allow authenticated users to create and read pre-registration records
    match /RegisterAttendance/{registrationId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null;
      allow update, delete: if request.auth != null && 
        (request.auth.uid == resource.data.customerUid || 
         resource.data.customerUid == 'manual' || 
         resource.data.customerUid == 'without_login');
    }
    
    // Events access rules with public/private and organization scoping
    match /Events/{eventId} {
      function isOrgMember(orgId) {
        return exists(/databases/$(database)/documents/Organizations/$(orgId)/Members/$(request.auth.uid));
      }

      function canWriteEvent() {
        return request.auth != null && (
          request.auth.uid == resource.data.customerUid ||
          request.auth.uid in resource.data.coHosts ||
          (
            resource.data.organizationId != null &&
            exists(/databases/$(database)/documents/Organizations/$(resource.data.organizationId)/Members/$(request.auth.uid)) &&
            (
              // If membership has permissions array containing CreateEditEvents
              (get(/databases/$(database)/documents/Organizations/$(resource.data.organizationId)/Members/$(request.auth.uid)).data.permissions != null &&
               'CreateEditEvents' in get(/databases/$(database)/documents/Organizations/$(resource.data.organizationId)/Members/$(request.auth.uid)).data.permissions)
            )
          )
        );
      }

      // Read allowed if:
      // - event is public
      // - requesting user is owner or co-host
      // - user is in event's access list
      // - user is a member of the hosting organization (when applicable)
      // - user has an attendance record for this event (so profile can show past events)
      allow read: if request.auth != null && (
        resource.data.private == false ||
        request.auth.uid == resource.data.customerUid ||
        request.auth.uid in resource.data.coHosts ||
        (resource.data.accessList != null && request.auth.uid in resource.data.accessList) ||
        (resource.data.organizationId != null && isOrgMember(resource.data.organizationId)) ||
        exists(/databases/$(database)/documents/Attendance/$(eventId + '-' + request.auth.uid))
      );

      allow write: if canWriteEvent();
      allow create: if request.auth != null && request.auth.uid == request.resource.data.customerUid;

      // Private access request workflow for events
      match /AccessRequests/{userId} {
        function isHostOrCoHost() {
          return request.auth != null && (
            request.auth.uid == get(/databases/$(database)/documents/Events/$(eventId)).data.customerUid ||
            request.auth.uid in get(/databases/$(database)/documents/Events/$(eventId)).data.coHosts
          );
        }

        allow create: if request.auth != null && request.auth.uid == userId;
        allow read: if request.auth != null && (request.auth.uid == userId || isHostOrCoHost());
        allow update, delete: if isHostOrCoHost();
      }
    }
    
    // Organizations and membership rules
    match /Organizations/{orgId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null;
      // Allow updates by creator or admins
      allow update, delete: if request.auth != null && (
        request.auth.uid == resource.data.createdBy ||
        (resource.data.adminUids != null && request.auth.uid in resource.data.adminUids)
      );

      // Members subcollection
      match /Members/{userId} {
        // Read allowed to members. Support both schemas: docId == uid OR field userId == uid
        allow read: if request.auth != null && (
          userId == request.auth.uid ||
          (resource.data.userId != null && resource.data.userId == request.auth.uid) ||
          exists(/databases/$(database)/documents/Organizations/$(orgId)/Members/$(request.auth.uid))
        );
        // Creator can create their own initial membership; users can create their own doc (pending/approved handled by app)
        allow create: if request.auth != null && (
          request.auth.uid == userId ||
          request.auth.uid == get(/databases/$(database)/documents/Organizations/$(orgId)).data.createdBy
        );
        // Updates/deletes by the user themself or any admin
        allow update, delete: if request.auth != null && (
          request.auth.uid == userId ||
          (exists(/databases/$(database)/documents/Organizations/$(orgId)/Members/$(request.auth.uid)) &&
           'ManageMembersRoles' in get(/databases/$(database)/documents/Organizations/$(orgId)/Members/$(request.auth.uid)).data.permissions)
        );
      }

      // JoinRequests subcollection
      match /JoinRequests/{requestId} {
        // Members can read; creator can also read
        allow read: if request.auth != null && (
          exists(/databases/$(database)/documents/Organizations/$(orgId)/Members/$(request.auth.uid)) ||
          request.auth.uid == get(/databases/$(database)/documents/Organizations/$(orgId)).data.createdBy
        );
        // Anyone authenticated can create a request for themself
        allow create: if request.auth != null && request.auth.uid == request.resource.data.userId;
        // Admins can update/delete requests
        allow update, delete: if request.auth != null && (
          request.auth.uid == get(/databases/$(database)/documents/Organizations/$(orgId)).data.createdBy ||
          (exists(/databases/$(database)/documents/Organizations/$(orgId)/Members/$(request.auth.uid)) &&
           'ApproveJoinRequests' in get(/databases/$(database)/documents/Organizations/$(orgId)/Members/$(request.auth.uid)).data.permissions)
        );
      }
    }
    
    // Collection group access for membership documents across organizations
    // Needed for collectionGroup('Members') queries such as loading a user's organizations
    match /{path=**}/Members/{memberId} {
      allow read: if request.auth != null && resource.data.userId == request.auth.uid;
    }
    
    // Allow event hosts and co-hosts to read/write their event analytics
    match /event_analytics/{eventId} {
      allow read, write: if request.auth != null && 
        exists(/databases/$(database)/documents/Events/$(eventId)) &&
        (request.auth.uid == get(/databases/$(database)/documents/Events/$(eventId)).data.customerUid ||
         request.auth.uid in get(/databases/$(database)/documents/Events/$(eventId)).data.coHosts);
    }
    
    // Allow users to read/write their own event questions
    // Also allow reading event questions for public events
    // Co-hosts can also write to event questions
    match /Events/{eventId}/EventQuestions/{questionId} {
      allow read: if request.auth != null && 
        (exists(/databases/$(database)/documents/Events/$(eventId)) &&
        (get(/databases/$(database)/documents/Events/$(eventId)).data.customerUid == request.auth.uid || 
         request.auth.uid in get(/databases/$(database)/documents/Events/$(eventId)).data.coHosts ||
         get(/databases/$(database)/documents/Events/$(eventId)).data.private == false));
      allow write: if request.auth != null && 
        exists(/databases/$(database)/documents/Events/$(eventId)) &&
        (request.auth.uid == get(/databases/$(database)/documents/Events/$(eventId)).data.customerUid ||
         request.auth.uid in get(/databases/$(database)/documents/Events/$(eventId)).data.coHosts);
      allow create: if request.auth != null && 
        exists(/databases/$(database)/documents/Events/$(eventId)) &&
        (request.auth.uid == get(/databases/$(database)/documents/Events/$(eventId)).data.customerUid ||
         request.auth.uid in get(/databases/$(database)/documents/Events/$(eventId)).data.coHosts);
    }
    
    // Organizations: allow authenticated users to create; owner or admins can modify
    match /Organizations/{organizationId} {
      // Read allowed for authenticated users (adjust as needed)
      allow read: if request.auth != null;
      
      // Create allowed for any authenticated user creating an org document
      allow create: if request.auth != null;
      
      // Updates/deletes restricted to creator or admins list if present
      allow update, delete: if request.auth != null && (
        request.auth.uid == resource.data.createdBy ||
        (resource.data.adminUids != null && request.auth.uid in resource.data.adminUids)
      );
    }
    
    // Allow authenticated users to create and read tickets
    // Users can create tickets for events that have tickets enabled
    // Users can read their own tickets
    // Event hosts can read tickets for their events
    match /Tickets/{ticketId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null;
      allow update: if request.auth != null;
    }

    // User badges (profile badges with stats)
    // Each user can read/write only their own badge document
    match /UserBadges/{userId} {
      allow read: if request.auth != null && request.auth.uid == userId;
      allow create: if request.auth != null && request.auth.uid == userId;
      allow update: if request.auth != null && request.auth.uid == userId;
      allow delete: if request.auth != null && request.auth.uid == userId;
    }
    
    // Allow users to read/write their own notifications
    match /users/{userId}/notifications/{notificationId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }
    
    // Allow users to read/write their own notification settings
    match /users/{userId}/settings/notifications {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }
    
    // Allow system to create scheduled notifications
    match /scheduledNotifications/{notificationId} {
      allow read, write: if request.auth != null;
    }
    
    // Allow users to read/write conversations they are part of (legacy 1-1 and new group schema)
    match /Conversations/{conversationId} {
      function isParticipant() {
        return request.auth != null && (
          request.auth.uid == resource.data.participant1Id ||
          request.auth.uid == resource.data.participant2Id ||
          (resource.data.participantIds != null && request.auth.uid in resource.data.participantIds)
        );
      }

      function isParticipantOnCreate() {
        return request.auth != null && (
          request.auth.uid == request.resource.data.participant1Id ||
          request.auth.uid == request.resource.data.participant2Id ||
          (request.resource.data.participantIds != null && request.auth.uid in request.resource.data.participantIds)
        );
      }

      allow read, write: if isParticipant();
      allow create: if isParticipantOnCreate();
    }

    // Allow users to read/write messages in conversations they are part of
    match /Messages/{messageId} {
      function conversationDoc() {
        return get(/databases/$(database)/documents/Conversations/$(resource.data.conversationId));
      }
      function conversationDocOnCreate() {
        return get(/databases/$(database)/documents/Conversations/$(request.resource.data.conversationId));
      }
      function isConvParticipant(doc) {
        return request.auth != null && (
          request.auth.uid == doc.data.participant1Id ||
          request.auth.uid == doc.data.participant2Id ||
          (doc.data.participantIds != null && request.auth.uid in doc.data.participantIds)
        );
      }

      // Read allowed if user is sender/receiver (legacy) OR member of the conversation (via conversationId)
      allow read: if request.auth != null && (
        request.auth.uid == resource.data.senderId ||
        request.auth.uid == resource.data.receiverId ||
        (
          resource.data.conversationId != null &&
          isConvParticipant(conversationDoc())
        )
      );

      // Create allowed only by sender who is participant of the conversation
      allow create: if request.auth != null &&
        request.auth.uid == request.resource.data.senderId &&
        request.resource.data.conversationId != null &&
        isConvParticipant(conversationDocOnCreate());

      // Allow participants to mark messages as read (only isRead/readByUserIds fields)
      allow update: if request.auth != null &&
        resource.data.conversationId != null &&
        isConvParticipant(conversationDoc()) &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['isRead', 'readByUserIds']);
    }
    
    // Allow users to read/write their own user data for FCM tokens
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }
  }
} 